use clap::Parser;
use confique::Config;
use gen::cli::{Cli, Subcommands};
use gen::config::Conf;
use gen::edit::change_file;
use serde_json::to_string_pretty;
use std::path::PathBuf;
use std::process::Command;
use walkdir::WalkDir;

fn get_txt_files() -> std::io::Result<Vec<PathBuf>> {
    let mut path = std::env::current_dir()?;
    path.push("bazel/");
    let mut paths = Vec::new();
    for entry in WalkDir::new(&path) {
        let entry = entry?;
        if entry.file_type().is_file()
            && entry.path().extension().and_then(std::ffi::OsStr::to_str) == Some("txt")
        {
            paths.push(entry.path().to_path_buf());
        }
    }
    Ok(paths)
}

fn create_pull_request(words: &Vec<String>) {
    let branch_name = format!("change/{}", words.join("-"));

    let output = Command::new("git")
        .arg("checkout")
        .arg("-t")
        .arg("-b")
        .arg(&branch_name)
        .output()
        .expect("Failed to execute command");

    if !output.status.success() {
        panic!("Command executed with failing error code");
    }

    let output = Command::new("git")
        .arg("commit")
        .arg("-am")
        .arg(format!("Moving words {}", words.join(", ")))
        .output()
        .expect("Failed to execute command");

    if !output.status.success() {
        panic!("Command executed with failing error code");
    }

    let output = Command::new("git")
        .arg("push")
        .arg("--set-upstream")
        .arg("origin")
        .arg("HEAD")
        .output()
        .expect("Failed to execute command");

    if !output.status.success() {
        eprintln!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        panic!("Failed to push the current branch to the remote repository");
    }

    let output = Command::new("gh")
        .arg("pr")
        .arg("create")
        .arg("--title")
        .arg(format!("{}", words.join(", ")))
        .arg("--body")
        .arg("This PR was generated by the trunk-pr-generator tool.")
        .output()
        .expect("Failed to execute command");

    if !output.status.success() {
        eprintln!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        panic!("Call to create PR on GitHub failed");
    }

    println!("Created PR: {}", String::from_utf8_lossy(&output.stdout));
}

fn run() -> anyhow::Result<()> {
    let cli: Cli = Cli::parse();

    if let Some(Subcommands::Genconfig {}) = &cli.subcommand {
        Conf::print_default();
        return Ok(());
    }
    let config = Conf::builder()
        .env()
        .file("demo.toml")
        .file(".config/demo.toml")
        .load()
        .unwrap_or_else(|err| {
            eprintln!("Generator cannot run: {}", err);
            std::process::exit(1);
        });

    if let Some(Subcommands::Config {}) = &cli.subcommand {
        let config_json = to_string_pretty(&config).expect("Failed to serialize config to JSON");
        println!("{}", config_json);
        return Ok(());
    }

    println!("{:?}", config.mode);

    println!("{:?}", cli.gh_token);

    let files = get_txt_files()?;
    let mut filenames: Vec<String> = files
        .into_iter()
        .map(|path| path.to_string_lossy().into_owned())
        .collect();

    filenames.sort();
    let filenames: Vec<String> = filenames.into_iter().take(config.max_deps).collect();

    let max_impacted_deps = config.max_impacted_deps as u32; // Convert usize to u32
    let words = change_file(&filenames, max_impacted_deps); // Use the converted value

    println!("::set-output name=words::{}", words.join(", "));
    println!("::set-output name=words-in-one::{}", words.join("-"));

    create_pull_request(&words);

    Ok(())
}

fn main() {
    env_logger::init();

    match run() {
        Ok(_) => (),
        Err(err) => {
            log::error!("{}", err);
            std::process::exit(1);
        }
    }
}
